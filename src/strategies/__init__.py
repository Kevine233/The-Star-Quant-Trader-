"""
"跟随庄家"自动交易系统的策略引擎模块。
本模块负责基于庄家指标和市场数据生成交易信号。
"""

from abc import ABC, abstractmethod
import pandas as pd
import numpy as np
from typing import Dict, List, Optional, Union, Any, Tuple
import datetime
import logging

# 配置日志
logger = logging.getLogger(__name__)

class 策略(ABC):
    """所有交易策略的抽象基类。"""
    
    def __init__(self, 名称: str, 描述: str = ""):
        """
        初始化策略。
        
        参数:
            名称: 策略名称
            描述: 策略描述
        """
        self.名称 = 名称
        self.描述 = 描述
        self.参数 = {}
        
    def 设置参数(self, 参数: Dict[str, Any]) -> None:
        """
        设置策略参数。
        
        参数:
            参数: 参数名-值对的字典
        """
        self.参数 = 参数
        
    @abstractmethod
    def 生成信号(self, 市场数据: pd.DataFrame, 
               庄家数据: pd.DataFrame,
               额外数据: Optional[Dict[str, Any]] = None) -> pd.DataFrame:
        """
        基于输入数据生成交易信号。
        
        参数:
            市场数据: 市场数据(OHLCV)
            庄家数据: 庄家指标数据
            额外数据: 信号生成所需的任何额外数据
            
        返回:
            带有信号的DataFrame(1表示买入，-1表示卖出，0表示持有)
        """
        pass
    
    @abstractmethod
    def 解释信号(self, 时间戳: Union[str, datetime.datetime], 
               市场数据: pd.DataFrame,
               庄家数据: pd.DataFrame,
               信号: int) -> str:
        """
        为特定信号提供解释。
        
        参数:
            时间戳: 信号时间戳
            市场数据: 用于信号生成的市场数据
            庄家数据: 用于信号生成的庄家数据
            信号: 信号值(1, -1或0)
            
        返回:
            信号的文字解释
        """
        pass


class 跟随庄家策略(策略):
    """
    基于庄家操纵分数跟随庄家动向的策略。
    这是实现"跟随庄家"核心理念的主要策略。
    """
    
    def __init__(self):
        """初始化跟随庄家策略。"""
        super().__init__(
            名称="跟随庄家策略",
            描述="通过分析操纵模式跟踪机构投资者和庄家动向"
        )
        # 默认参数(将通过回测优化)
        self.参数 = {
            "操纵分数阈值": 0.7,           # 触发信号的操纵分数阈值
            "成交量权重": 0.3,            # 成交量异常在操纵分数中的权重
            "价格模式权重": 0.3,          # 价格模式识别在操纵分数中的权重
            "机构活动权重": 0.4,          # 机构活动在操纵分数中的权重
            "入场确认周期": 2,            # 确认入场的周期数
            "止损百分比": 0.05,           # 止损百分比
            "止盈百分比": 0.15,           # 止盈百分比
            "最大持仓周期": 20,           # 最大持仓周期
            "仓位大小百分比": 0.1         # 仓位大小占投资组合的百分比
        }
    
    def 计算操纵分数(self, 
                 市场数据: pd.DataFrame, 
                 庄家数据: pd.DataFrame,
                 行索引: int) -> Tuple[float, Dict[str, float]]:
        """
        计算特定数据点的操纵分数。
        
        参数:
            市场数据: 市场数据(OHLCV)
            庄家数据: 庄家指标数据
            行索引: 要计算分数的行索引
            
        返回:
            (操纵分数, 组成分数)的元组
        """
        # 这是一个简化实现，实际应用中会使用更复杂的指标
        # 在真实实现中，我们会基于研究使用更复杂的方法
        
        组成分数 = {}
        
        # 1. 成交量异常检测
        try:
            最近成交量 = 市场数据['volume'].iloc[max(0, 行索引-10):行索引+1]
            平均成交量 = 最近成交量.mean()
            当前成交量 = 市场数据['volume'].iloc[行索引]
            成交量比率 = 当前成交量 / 平均成交量 if 平均成交量 > 0 else 1.0
            成交量分数 = min(1.0, 成交量比率 / 3.0)  # 归一化，上限为1.0
            组成分数['成交量异常'] = 成交量分数
        except Exception as e:
            logger.warning(f"计算成交量分数出错: {e}")
            成交量分数 = 0.0
            组成分数['成交量异常'] = 0.0
            
        # 2. 价格模式识别
        try:
            # 简单模式：盘整后价格上涨
            最近价格 = 市场数据['close'].iloc[max(0, 行索引-5):行索引+1]
            价格标准差 = 最近价格.std() / 最近价格.mean() if len(最近价格) > 1 else 0
            价格变化 = (市场数据['close'].iloc[行索引] / 市场数据['close'].iloc[max(0, 行索引-1)] - 1) 
            
            # 低波动性后出现显著价格变化可能表明积累
            if 价格标准差 < 0.02 and 价格变化 > 0.02:
                模式分数 = min(1.0, 价格变化 / 0.05)  # 归一化，上限为1.0
            else:
                模式分数 = 0.0
                
            组成分数['价格模式'] = 模式分数
        except Exception as e:
            logger.warning(f"计算价格模式分数出错: {e}")
            模式分数 = 0.0
            组成分数['价格模式'] = 0.0
            
        # 3. 机构活动(来自庄家数据)
        try:
            # 这将使用实际的机构数据
            # 现在，我们使用基于可用列的占位符
            if 'institutional_activity' in 庄家数据.columns:
                机构活动 = 庄家数据['institutional_activity'].iloc[行索引]
                机构分数 = min(1.0, max(0.0, 机构活动))
            else:
                # 如果没有真实的机构数据，使用占位符逻辑
                机构分数 = 0.5  # 中性分数作为占位符
                
            组成分数['机构活动'] = 机构分数
        except Exception as e:
            logger.warning(f"计算机构活动分数出错: {e}")
            机构分数 = 0.0
            组成分数['机构活动'] = 0.0
            
        # 计算加权操纵分数
        操纵分数 = (
            self.参数['成交量权重'] * 成交量分数 +
            self.参数['价格模式权重'] * 模式分数 +
            self.参数['机构活动权重'] * 机构分数
        )
        
        return 操纵分数, 组成分数
    
    def 生成信号(self, 市场数据: pd.DataFrame, 
               庄家数据: pd.DataFrame,
               额外数据: Optional[Dict[str, Any]] = None) -> pd.DataFrame:
        """
        基于庄家指标生成交易信号。
        
        参数:
            市场数据: 市场数据(OHLCV)
            庄家数据: 庄家指标数据
            额外数据: 信号生成所需的任何额外数据
            
        返回:
            带有信号和额外分析列的DataFrame
        """
        # 确保DataFrame索引对齐
        if isinstance(市场数据.index, pd.DatetimeIndex) and isinstance(庄家数据.index, pd.DatetimeIndex):
            # 按日期时间索引对齐
            共同索引 = 市场数据.index.intersection(庄家数据.index)
            市场数据 = 市场数据.loc[共同索引]
            庄家数据 = 庄家数据.loc[共同索引]
        
        # 初始化结果DataFrame
        结果 = 市场数据.copy()
        结果['信号'] = 0  # 默认：无信号(持有)
        结果['操纵分数'] = 0.0
        结果['成交量异常分数'] = 0.0
        结果['价格模式分数'] = 0.0
        结果['机构活动分数'] = 0.0
        结果['信号解释'] = ""
        
        # 跟踪持仓状态
        持仓中 = False
        入场价格 = 0.0
        入场日期 = None
        确认计数 = 0
        
        # 处理每个数据点
        for i in range(len(结果)):
            # 计算操纵分数
            操纵分数, 组成分数 = self.计算操纵分数(
                市场数据, 庄家数据, i
            )
            
            # 将分数存储在结果中
            结果.loc[结果.index[i], '操纵分数'] = 操纵分数
            结果.loc[结果.index[i], '成交量异常分数'] = 组成分数.get('成交量异常', 0.0)
            结果.loc[结果.index[i], '价格模式分数'] = 组成分数.get('价格模式', 0.0)
            结果.loc[结果.index[i], '机构活动分数'] = 组成分数.get('机构活动', 0.0)
            
            当前价格 = 结果['close'].iloc[i]
            
            # 交易逻辑
            if not 持仓中:
                # 入场逻辑
                if 操纵分数 >= self.参数['操纵分数阈值']:
                    确认计数 += 1
                    
                    if 确认计数 >= self.参数['入场确认周期']:
                        # 生成买入信号
                        结果.loc[结果.index[i], '信号'] = 1
                        持仓中 = True
                        入场价格 = 当前价格
                        入场日期 = 结果.index[i]
                        持仓开始索引 = i
                        
                        # 生成解释
                        解释 = (
                            f"买入信号：操纵分数 {操纵分数:.2f} 超过阈值 "
                            f"({self.参数['操纵分数阈值']:.2f})。"
                            f"组成分数：成交量异常 {组成分数.get('成交量异常', 0.0):.2f}，"
                            f"价格模式 {组成分数.get('价格模式', 0.0):.2f}，"
                            f"机构活动 {组成分数.get('机构活动', 0.0):.2f}。"
                        )
                        结果.loc[结果.index[i], '信号解释'] = 解释
                else:
                    确认计数 = 0
            else:
                # 出场逻辑
                持仓周期 = i - 持仓开始索引
                
                # 1. 止损
                if 当前价格 <= 入场价格 * (1 - self.参数['止损百分比']):
                    结果.loc[结果.index[i], '信号'] = -1
                    持仓中 = False
                    解释 = (
                        f"卖出信号：触发止损。入场价格：{入场价格:.2f}，"
                        f"当前价格：{当前价格:.2f}，亏损：{((当前价格/入场价格)-1)*100:.2f}%"
                    )
                    结果.loc[结果.index[i], '信号解释'] = 解释
                
                # 2. 止盈
                elif 当前价格 >= 入场价格 * (1 + self.参数['止盈百分比']):
                    结果.loc[结果.index[i], '信号'] = -1
                    持仓中 = False
                    解释 = (
                        f"卖出信号：触发止盈。入场价格：{入场价格:.2f}，"
                        f"当前价格：{当前价格:.2f}，盈利：{((当前价格/入场价格)-1)*100:.2f}%"
                    )
                    结果.loc[结果.index[i], '信号解释'] = 解释
                
                # 3. 最大持仓周期
                elif 持仓周期 >= self.参数['最大持仓周期']:
                    结果.loc[结果.index[i], '信号'] = -1
                    持仓中 = False
                    解释 = (
                        f"卖出信号：达到最大持仓周期({持仓周期}个周期)。"
                        f"入场价格：{入场价格:.2f}，当前价格：{当前价格:.2f}，"
                        f"盈亏：{((当前价格/入场价格)-1)*100:.2f}%"
                    )
                    结果.loc[结果.index[i], '信号解释'] = 解释
                
                # 4. 操纵分数反转(可选，可通过参数启用)
                # 这将在庄家从积累转为分发时退出
                
        return 结果
    
    def 解释信号(self, 时间戳: Union[str, datetime.datetime], 
               市场数据: pd.DataFrame,
               庄家数据: pd.DataFrame,
               信号: int) -> str:
        """
        为特定信号提供详细解释。
        
        参数:
            时间戳: 信号时间戳
            市场数据: 用于信号生成的市场数据
            庄家数据: 用于信号生成的庄家数据
            信号: 信号值(1, -1或0)
            
        返回:
            信号的文字解释
        """
        # 将时间戳转换为适当的格式(如果需要)
        if isinstance(时间戳, str):
            时间戳 = pd.to_datetime(时间戳)
        
        # 在数据中查找对应的行
        if 时间戳 in 市场数据.index:
            索引 = 市场数据.index.get_loc(时间戳)
            
            # 计算该点的操纵分数
            操纵分数, 组成分数 = self.计算操纵分数(
                市场数据, 庄家数据, 索引
            )
            
            if 信号 == 1:  # 买入信号
                return (
                    f"在 {时间戳} 生成买入信号：\n"
                    f"- 操纵分数：{操纵分数:.2f} (阈值：{self.参数['操纵分数阈值']:.2f})\n"
                    f"- 成交量异常：{组成分数.get('成交量异常', 0.0):.2f} (权重：{self.参数['成交量权重']:.2f})\n"
                    f"- 价格模式：{组成分数.get('价格模式', 0.0):.2f} (权重：{self.参数['价格模式权重']:.2f})\n"
                    f"- 机构活动：{组成分数.get('机构活动', 0.0):.2f} (权重：{self.参数['机构活动权重']:.2f})\n"
                    f"- 收盘价：{市场数据['close'].iloc[索引]:.2f}\n"
                    f"- 仓位大小：投资组合的 {self.参数['仓位大小百分比']*100:.1f}%\n"
                    f"- 止损设置在：{市场数据['close'].iloc[索引] * (1 - self.参数['止损百分比']):.2f} "
                    f"(低于入场价 {self.参数['止损百分比']*100:.1f}%)\n"
                    f"- 止盈目标：{市场数据['close'].iloc[索引] * (1 + self.参数['止盈百分比']):.2f} "
                    f"(高于入场价 {self.参数['止盈百分比']*100:.1f}%)"
                )
            elif 信号 == -1:  # 卖出信号
                # 对于卖出信号，我们需要更多关于入场的上下文
                # 这是简化的，在实际实现中会增强
                return (
                    f"在 {时间戳} 生成卖出信号：\n"
                    f"- 收盘价：{市场数据['close'].iloc[索引]:.2f}\n"
                    f"- 当前操纵分数：{操纵分数:.2f}\n"
                    f"- 原因：触发退出条件(止损、止盈或最大持仓周期)"
                )
            else:  # 持有或无信号
                return (
                    f"在 {时间戳} 没有交易信号：\n"
                    f"- 操纵分数：{操纵分数:.2f} (阈值：{self.参数['操纵分数阈值']:.2f})\n"
                    f"- 分数低于阈值，继续监控"
                )
        else:
            return f"时间戳 {时间戳} 没有可用数据"


class 策略工厂:
    """创建策略实例的工厂类。"""
    
    @staticmethod
    def 创建策略(策略名称: str, 参数: Optional[Dict[str, Any]] = None) -> 策略:
        """
        根据名称创建策略实例。
        
        参数:
            策略名称: 要创建的策略名称
            参数: 要设置在策略上的可选参数
            
        返回:
            策略实例
            
        异常:
            ValueError: 如果策略名称不被识别
        """
        if 策略名称.lower() in ["跟随庄家", "跟随庄家策略", "smart_money_follow"]:
            策略实例 = 跟随庄家策略()
        else:
            raise ValueError(f"未知策略: {策略名称}")
        
        if 参数:
            策略实例.设置参数(参数)
            
        return 策略实例
