"""
模拟盘模块，提供基于实时行情的模拟交易功能。
本模块允许用户在不投入实际资金的情况下，使用实时市场数据测试策略表现。
"""

import os
import json
import datetime
import logging
import threading
import time
import copy
from typing import Dict, List, Any, Optional, Union, Tuple

import pandas as pd
import numpy as np

# 配置日志
logger = logging.getLogger(__name__)

class 模拟交易执行器:
    """
    模拟交易执行器类，负责执行模拟交易。
    使用与实盘相同的交易逻辑，但不发送实际交易指令。
    """
    
    def __init__(self, 
               数据源 = None,
               策略引擎 = None,
               风控模块 = None,
               通知模块 = None,
               配置: Dict[str, Any] = None):
        """
        初始化模拟交易执行器。
        
        参数:
            数据源: 数据源实例，用于获取实时行情
            策略引擎: 策略引擎实例，用于生成交易信号
            风控模块: 风险控制模块实例
            通知模块: 通知模块实例
            配置: 模拟交易执行器配置字典
        """
        self.数据源 = 数据源
        self.策略引擎 = 策略引擎
        self.风控模块 = 风控模块
        self.通知模块 = 通知模块
        self.配置 = 配置 if 配置 is not None else {}
        
        # 设置默认配置
        self.配置.setdefault('初始资金', 1000000)  # 默认100万初始资金
        self.配置.setdefault('手续费率', 0.0003)   # 默认万分之三手续费率
        self.配置.setdefault('滑点', 0.0001)      # 默认万分之一滑点
        self.配置.setdefault('更新频率', 5)        # 默认5秒更新一次
        
        # 模拟账户状态
        self.账户 = {
            '初始资金': self.配置['初始资金'],
            '当前资金': self.配置['初始资金'],
            '持仓市值': 0,
            '总资产': self.配置['初始资金'],
            '持仓': {},
            '历史净值': [],
            '交易记录': []
        }
        
        # 运行状态
        self.运行中 = False
        self.开始时间 = None
        self.最后更新时间 = None
        
        # 模拟交易线程
        self.交易线程 = None
        
        # 行情缓存
        self.行情缓存 = {}
        
        # 信号缓存
        self.信号缓存 = {}
    
    def 启动(self) -> bool:
        """
        启动模拟交易。
        
        返回:
            启动是否成功
        """
        if self.运行中:
            logger.warning("模拟交易已经在运行中")
            return True
        
        # 检查必要组件
        if not self.数据源:
            logger.error("数据源未初始化，无法启动模拟交易")
            return False
        
        if not self.策略引擎:
            logger.error("策略引擎未初始化，无法启动模拟交易")
            return False
        
        # 初始化账户状态
        self._初始化账户()
        
        # 启动交易线程
        self.运行中 = True
        self.开始时间 = datetime.datetime.now()
        self.最后更新时间 = self.开始时间
        self.交易线程 = threading.Thread(target=self._交易线程函数, daemon=True)
        self.交易线程.start()
        
        logger.info("模拟交易已启动")
        
        # 发送通知
        if self.通知模块:
            self.通知模块.发送通知("模拟交易已启动", "模拟交易已成功启动，开始接收实时行情和交易信号。")
        
        return True
    
    def 停止(self) -> bool:
        """
        停止模拟交易。
        
        返回:
            停止是否成功
        """
        if not self.运行中:
            logger.warning("模拟交易已经停止")
            return True
        
        # 停止交易线程
        self.运行中 = False
        if self.交易线程:
            self.交易线程.join(timeout=5.0)
            self.交易线程 = None
        
        logger.info("模拟交易已停止")
        
        # 发送通知
        if self.通知模块:
            self.通知模块.发送通知("模拟交易已停止", "模拟交易已停止运行，不再接收实时行情和交易信号。")
        
        return True
    
    def 重置(self) -> bool:
        """
        重置模拟账户状态。
        
        返回:
            重置是否成功
        """
        # 如果正在运行，先停止
        if self.运行中:
            self.停止()
        
        # 重置账户状态
        self._初始化账户()
        
        logger.info("模拟账户已重置")
        return True
    
    def 获取账户状态(self) -> Dict[str, Any]:
        """
        获取当前模拟账户状态。
        
        返回:
            账户状态字典
        """
        # 更新总资产
        self.账户['总资产'] = self.账户['当前资金'] + self.账户['持仓市值']
        
        # 计算收益率
        收益率 = (self.账户['总资产'] / self.账户['初始资金'] - 1) * 100
        
        # 构建完整账户状态
        账户状态 = copy.deepcopy(self.账户)
        账户状态['收益率'] = 收益率
        账户状态['运行状态'] = '运行中' if self.运行中 else '已停止'
        账户状态['开始时间'] = self.开始时间
        账户状态['最后更新时间'] = self.最后更新时间
        账户状态['运行时长'] = (datetime.datetime.now() - self.开始时间).total_seconds() if self.开始时间 else 0
        
        return 账户状态
    
    def 获取交易记录(self, 数量: int = None) -> List[Dict[str, Any]]:
        """
        获取模拟交易记录。
        
        参数:
            数量: 要获取的记录条数，如果为None则获取所有记录
            
        返回:
            交易记录列表
        """
        if 数量 is None:
            return self.账户['交易记录']
        else:
            return self.账户['交易记录'][-数量:]
    
    def 获取历史净值(self) -> pd.DataFrame:
        """
        获取历史净值数据。
        
        返回:
            历史净值DataFrame，包含日期、净值、收益率等
        """
        if not self.账户['历史净值']:
            return pd.DataFrame(columns=['日期', '净值', '收益率'])
        
        return pd.DataFrame(self.账户['历史净值'])
    
    def 获取持仓信息(self) -> Dict[str, Any]:
        """
        获取当前持仓信息。
        
        返回:
            持仓信息字典
        """
        return copy.deepcopy(self.账户['持仓'])
    
    def 是否运行中(self) -> bool:
        """
        检查模拟交易是否在运行中。
        
        返回:
            是否在运行中
        """
        return self.运行中
    
    def _初始化账户(self):
        """初始化模拟账户状态。"""
        self.账户 = {
            '初始资金': self.配置['初始资金'],
            '当前资金': self.配置['初始资金'],
            '持仓市值': 0,
            '总资产': self.配置['初始资金'],
            '持仓': {},
            '历史净值': [{
                '日期': datetime.datetime.now(),
                '净值': 1.0,
                '收益率': 0.0,
                '当前资金': self.配置['初始资金'],
                '持仓市值': 0,
                '总资产': self.配置['初始资金']
            }],
            '交易记录': []
        }
    
    def _交易线程函数(self):
        """模拟交易线程的主函数。"""
        logger.info("模拟交易线程已启动")
        
        while self.运行中:
            try:
                # 更新行情数据
                self._更新行情()
                
                # 获取交易信号
                self._获取交易信号()
                
                # 执行交易
                self._执行交易()
                
                # 更新账户状态
                self._更新账户状态()
                
                # 更新最后更新时间
                self.最后更新时间 = datetime.datetime.now()
                
                # 休眠一段时间
                time.sleep(self.配置['更新频率'])
            except Exception as e:
                logger.error(f"模拟交易线程发生错误: {str(e)}", exc_info=True)
                time.sleep(10.0)  # 发生错误时暂停更长时间
        
        logger.info("模拟交易线程已停止")
    
    def _更新行情(self):
        """更新实时行情数据。"""
        try:
            # 获取所有关注的标的
            关注标的 = self._获取关注标的()
            
            # 获取实时行情
            for 标的 in 关注标的:
                行情 = self.数据源.获取实时行情(标的)
                if 行情:
                    self.行情缓存[标的] = 行情
            
            # 更新持仓市值
            self._更新持仓市值()
        except Exception as e:
            logger.error(f"更新行情时发生错误: {str(e)}")
    
    def _获取交易信号(self):
        """获取策略生成的交易信号。"""
        try:
            if not self.策略引擎:
                return
            
            # 获取最新交易信号
            信号列表 = self.策略引擎.获取最新信号()
            
            # 处理交易信号
            for 信号 in 信号列表:
                self.信号缓存[信号['标的']] = 信号
        except Exception as e:
            logger.error(f"获取交易信号时发生错误: {str(e)}")
    
    def _执行交易(self):
        """执行模拟交易。"""
        try:
            # 处理所有待执行的交易信号
            for 标的, 信号 in list(self.信号缓存.items()):
                # 检查是否有行情数据
                if 标的 not in self.行情缓存:
                    continue
                
                # 获取行情数据
                行情 = self.行情缓存[标的]
                
                # 执行交易
                self._执行单个交易(信号, 行情)
                
                # 从信号缓存中移除已处理的信号
                del self.信号缓存[标的]
        except Exception as e:
            logger.error(f"执行交易时发生错误: {str(e)}")
    
    def _执行单个交易(self, 信号: Dict[str, Any], 行情: Dict[str, Any]):
        """
        执行单个模拟交易。
        
        参数:
            信号: 交易信号字典
            行情: 行情数据字典
        """
        # 提取必要信息
        标的 = 信号['标的']
        方向 = 信号['方向']
        数量 = 信号['数量']
        价格类型 = 信号.get('价格类型', '市价')
        价格 = 信号.get('价格')
        信号来源 = 信号.get('信号来源', '未知')
        信号解释 = 信号.get('信号解释', '')
        
        # 确定成交价格
        if 价格类型 == '市价':
            # 市价单，使用当前价格加减滑点
            if 方向 == '买入':
                成交价格 = 行情['卖一价'] * (1 + self.配置['滑点'])
            else:  # 卖出
                成交价格 = 行情['买一价'] * (1 - self.配置['滑点'])
        else:  # 限价单
            # 检查限价单是否能够成交
            if 方向 == '买入' and 价格 >= 行情['卖一价']:
                成交价格 = 行情['卖一价']
            elif 方向 == '卖出' and 价格 <= 行情['买一价']:
                成交价格 = 行情['买一价']
            else:
                # 限价单不能成交
                logger.info(f"限价单不能成交: {方向} {标的} {数量}股，限价: {价格}，当前价: {行情['最新价']}")
                return
        
        # 计算交易金额和手续费
        交易金额 = 成交价格 * 数量
        手续费 = 交易金额 * self.配置['手续费率']
        
        # 检查资金是否足够（买入时）
        if 方向 == '买入':
            所需资金 = 交易金额 + 手续费
            if 所需资金 > self.账户['当前资金']:
                logger.warning(f"资金不足，无法买入: 需要 {所需资金}，可用 {self.账户['当前资金']}")
                return
        
        # 检查持仓是否足够（卖出时）
        if 方向 == '卖出':
            if 标的 not in self.账户['持仓'] or self.账户['持仓'][标的]['数量'] < 数量:
                logger.warning(f"持仓不足，无法卖出: 需要 {数量}，可用 {self.账户['持仓'].get(标的, {}).get('数量', 0)}")
                return
        
        # 风险控制检查
        if self.风控模块:
            风控结果 = self.风控模块.检查交易(信号)
            if not 风控结果['通过']:
                logger.warning(f"交易未通过风控检查: {风控结果['原因']}")
                return
        
        # 执行交易
        if 方向 == '买入':
            # 更新资金
            self.账户['当前资金'] -= (交易金额 + 手续费)
            
            # 更新持仓
            if 标的 not in self.账户['持仓']:
                self.账户['持仓'][标的] = {
                    '数量': 0,
                    '成本': 0,
                    '市值': 0,
                    '最新价': 0,
                    '盈亏': 0,
                    '盈亏比例': 0
                }
            
            # 计算新的持仓成本
            原持仓数量 = self.账户['持仓'][标的]['数量']
            原持仓成本 = self.账户['持仓'][标的]['成本'] * 原持仓数量
            新持仓数量 = 原持仓数量 + 数量
            新持仓成本 = (原持仓成本 + 交易金额) / 新持仓数量
            
            # 更新持仓信息
            self.账户['持仓'][标的]['数量'] = 新持仓数量
            self.账户['持仓'][标的]['成本'] = 新持仓成本
            self.账户['持仓'][标的]['最新价'] = 行情['最新价']
            self.账户['持仓'][标的]['市值'] = 新持仓数量 * 行情['最新价']
            self.账户['持仓'][标的]['盈亏'] = self.账户['持仓'][标的]['市值'] - 新持仓数量 * 新持仓成本
            self.账户['持仓'][标的]['盈亏比例'] = self.账户['持仓'][标的]['盈亏'] / (新持仓数量 * 新持仓成本) * 100
        else:  # 卖出
            # 计算卖出部分的成本
            成本价 = self.账户['持仓'][标的]['成本']
            卖出成本 = 成本价 * 数量
            
            # 计算卖出盈亏
            卖出盈亏 = 交易金额 - 卖出成本
            
            # 更新资金
            self.账户['当前资金'] += (交易金额 - 手续费)
            
            # 更新持仓
            self.账户['持仓'][标的]['数量'] -= 数量
            self.账户['持仓'][标的]['最新价'] = 行情['最新价']
            
            # 如果持仓数量为0，计算总盈亏并移除持仓
            if self.账户['持仓'][标的]['数量'] == 0:
                self.账户['持仓'].pop(标的)
            else:
                # 更新持仓市值和盈亏
                self.账户['持仓'][标的]['市值'] = self.账户['持仓'][标的]['数量'] * 行情['最新价']
                self.账户['持仓'][标的]['盈亏'] = self.账户['持仓'][标的]['市值'] - self.账户['持仓'][标的]['数量'] * 成本价
                self.账户['持仓'][标的]['盈亏比例'] = self.账户['持仓'][标的]['盈亏'] / (self.账户['持仓'][标的]['数量'] * 成本价) * 100
        
        # 更新持仓市值
        self._更新持仓市值()
        
        # 记录交易
        交易记录 = {
            '时间': datetime.datetime.now(),
            '标的': 标的,
            '方向': 方向,
            '数量': 数量,
            '价格': 成交价格,
            '金额': 交易金额,
            '手续费': 手续费,
            '信号来源': 信号来源,
            '信号解释': 信号解释
        }
        
        # 添加买入/卖出特有字段
        if 方向 == '买入':
            交易记录['买入成本'] = 新持仓成本
        else:  # 卖出
            交易记录['卖出盈亏'] = 卖出盈亏
            交易记录['卖出盈亏比例'] = 卖出盈亏 / 卖出成本 * 100
        
        # 添加交易记录
        self.账户['交易记录'].append(交易记录)
        
        logger.info(f"模拟交易执行成功: {方向} {标的} {数量}股，价格: {成交价格}，金额: {交易金额}，手续费: {手续费}")
        
        # 发送通知
        if self.通知模块:
            self.通知模块.发送通知(
                f"模拟交易: {方向} {标的}",
                f"成功{方向} {标的} {数量}股，价格: {成交价格}，金额: {交易金额}，手续费: {手续费}，原因: {信号解释}"
            )
    
    def _更新账户状态(self):
        """更新模拟账户状态，包括总资产、收益率等。"""
        try:
            # 更新持仓市值
            self._更新持仓市值()
            
            # 计算总资产
            总资产 = self.账户['当前资金'] + self.账户['持仓市值']
            self.账户['总资产'] = 总资产
            
            # 计算净值和收益率
            净值 = 总资产 / self.账户['初始资金']
            收益率 = (净值 - 1) * 100
            
            # 记录历史净值
            当前时间 = datetime.datetime.now()
            
            # 每天只记录一次收盘净值，或者初始记录
            if not self.账户['历史净值'] or (当前时间 - self.账户['历史净值'][-1]['日期']).days >= 1:
                self.账户['历史净值'].append({
                    '日期': 当前时间,
                    '净值': 净值,
                    '收益率': 收益率,
                    '当前资金': self.账户['当前资金'],
                    '持仓市值': self.账户['持仓市值'],
                    '总资产': 总资产
                })
        except Exception as e:
            logger.error(f"更新账户状态时发生错误: {str(e)}")
    
    def _更新持仓市值(self):
        """更新持仓市值。"""
        持仓市值 = 0
        
        # 遍历所有持仓
        for 标的, 持仓 in list(self.账户['持仓'].items()):
            # 检查是否有最新行情
            if 标的 in self.行情缓存:
                最新价 = self.行情缓存[标的]['最新价']
                
                # 更新持仓信息
                持仓['最新价'] = 最新价
                持仓['市值'] = 持仓['数量'] * 最新价
                持仓['盈亏'] = 持仓['市值'] - 持仓['数量'] * 持仓['成本']
                持仓['盈亏比例'] = 持仓['盈亏'] / (持仓['数量'] * 持仓['成本']) * 100
                
                # 累加持仓市值
                持仓市值 += 持仓['市值']
        
        # 更新账户持仓市值
        self.账户['持仓市值'] = 持仓市值
    
    def _获取关注标的(self) -> List[str]:
        """
        获取需要关注的标的列表。
        包括当前持仓的标的和策略关注的标的。
        
        返回:
            标的代码列表
        """
        关注标的 = set()
        
        # 添加当前持仓的标的
        for 标的 in self.账户['持仓'].keys():
            关注标的.add(标的)
        
        # 添加策略关注的标的
        if self.策略引擎 and hasattr(self.策略引擎, '获取关注标的'):
            策略关注标的 = self.策略引擎.获取关注标的()
            关注标的.update(策略关注标的)
        
        return list(关注标的)


class 模拟盘对比分析:
    """
    模拟盘与回测结果对比分析类。
    用于比较模拟盘交易结果与回测结果的差异。
    """
    
    def __init__(self, 模拟交易执行器 = None, 回测引擎 = None):
        """
        初始化模拟盘对比分析。
        
        参数:
            模拟交易执行器: 模拟交易执行器实例
            回测引擎: 回测引擎实例
        """
        self.模拟交易执行器 = 模拟交易执行器
        self.回测引擎 = 回测引擎
    
    def 生成对比报告(self) -> Dict[str, Any]:
        """
        生成模拟盘与回测结果的对比报告。
        
        返回:
            对比报告字典
        """
        if not self.模拟交易执行器 or not self.回测引擎:
            return {
                'status': 'error',
                'message': '模拟交易执行器或回测引擎未初始化'
            }
        
        try:
            # 获取模拟盘数据
            模拟盘账户状态 = self.模拟交易执行器.获取账户状态()
            模拟盘历史净值 = self.模拟交易执行器.获取历史净值()
            模拟盘交易记录 = self.模拟交易执行器.获取交易记录()
            
            # 获取回测数据
            回测结果 = self.回测引擎.获取回测结果()
            回测历史净值 = self.回测引擎.获取历史净值()
            回测交易记录 = self.回测引擎.获取交易记录()
            
            # 计算关键指标
            模拟盘指标 = self._计算性能指标(模拟盘历史净值, 模拟盘交易记录)
            回测指标 = self._计算性能指标(回测历史净值, 回测交易记录)
            
            # 计算指标差异
            指标差异 = self._计算指标差异(模拟盘指标, 回测指标)
            
            # 生成对比图表数据
            图表数据 = self._生成图表数据(模拟盘历史净值, 回测历史净值)
            
            # 构建对比报告
            对比报告 = {
                'status': 'success',
                'data': {
                    '模拟盘指标': 模拟盘指标,
                    '回测指标': 回测指标,
                    '指标差异': 指标差异,
                    '图表数据': 图表数据,
                    '模拟盘账户状态': 模拟盘账户状态,
                    '回测结果': 回测结果
                }
            }
            
            return 对比报告
        except Exception as e:
            logger.error(f"生成对比报告时发生错误: {str(e)}", exc_info=True)
            return {
                'status': 'error',
                'message': f'生成对比报告时发生错误: {str(e)}'
            }
    
    def _计算性能指标(self, 历史净值: pd.DataFrame, 交易记录: List[Dict[str, Any]]) -> Dict[str, float]:
        """
        计算性能指标。
        
        参数:
            历史净值: 历史净值DataFrame
            交易记录: 交易记录列表
            
        返回:
            性能指标字典
        """
        if 历史净值.empty:
            return {
                '总收益率': 0,
                '年化收益率': 0,
                '夏普比率': 0,
                '最大回撤': 0,
                '收益回撤比': 0,
                '胜率': 0,
                '盈亏比': 0,
                '交易次数': 0
            }
        
        # 计算总收益率
        总收益率 = 历史净值['收益率'].iloc[-1]
        
        # 计算年化收益率
        开始日期 = 历史净值['日期'].iloc[0]
        结束日期 = 历史净值['日期'].iloc[-1]
        天数 = (结束日期 - 开始日期).days
        if 天数 > 0:
            年化收益率 = (1 + 总收益率 / 100) ** (365 / 天数) - 1
            年化收益率 *= 100
        else:
            年化收益率 = 0
        
        # 计算夏普比率
        if len(历史净值) > 1:
            收益率序列 = 历史净值['净值'].pct_change().dropna()
            if len(收益率序列) > 0:
                夏普比率 = 收益率序列.mean() / 收益率序列.std() * np.sqrt(252)
            else:
                夏普比率 = 0
        else:
            夏普比率 = 0
        
        # 计算最大回撤
        净值序列 = 历史净值['净值']
        最大回撤 = 0
        峰值 = 净值序列.iloc[0]
        
        for 净值 in 净值序列:
            if 净值 > 峰值:
                峰值 = 净值
            回撤 = (峰值 - 净值) / 峰值
            最大回撤 = max(最大回撤, 回撤)
        
        最大回撤 *= 100
        
        # 计算收益回撤比
        if 最大回撤 > 0:
            收益回撤比 = 年化收益率 / 最大回撤
        else:
            收益回撤比 = 0
        
        # 计算胜率和盈亏比
        盈利交易 = [交易 for 交易 in 交易记录 if 交易.get('方向') == '卖出' and 交易.get('卖出盈亏', 0) > 0]
        亏损交易 = [交易 for 交易 in 交易记录 if 交易.get('方向') == '卖出' and 交易.get('卖出盈亏', 0) <= 0]
        
        交易次数 = len(盈利交易) + len(亏损交易)
        
        if 交易次数 > 0:
            胜率 = len(盈利交易) / 交易次数
        else:
            胜率 = 0
        
        if 盈利交易 and 亏损交易:
            平均盈利 = sum(交易.get('卖出盈亏', 0) for 交易 in 盈利交易) / len(盈利交易)
            平均亏损 = sum(abs(交易.get('卖出盈亏', 0)) for 交易 in 亏损交易) / len(亏损交易)
            
            if 平均亏损 > 0:
                盈亏比 = 平均盈利 / 平均亏损
            else:
                盈亏比 = 0
        else:
            盈亏比 = 0
        
        return {
            '总收益率': 总收益率,
            '年化收益率': 年化收益率,
            '夏普比率': 夏普比率,
            '最大回撤': 最大回撤,
            '收益回撤比': 收益回撤比,
            '胜率': 胜率,
            '盈亏比': 盈亏比,
            '交易次数': 交易次数
        }
    
    def _计算指标差异(self, 模拟盘指标: Dict[str, float], 回测指标: Dict[str, float]) -> Dict[str, float]:
        """
        计算模拟盘与回测指标的差异。
        
        参数:
            模拟盘指标: 模拟盘性能指标字典
            回测指标: 回测性能指标字典
            
        返回:
            指标差异字典
        """
        差异 = {}
        
        for 指标 in 模拟盘指标.keys():
            差异[指标] = 模拟盘指标[指标] - 回测指标[指标]
            
            # 计算相对差异（百分比）
            if 回测指标[指标] != 0:
                差异[f'{指标}_相对'] = 差异[指标] / abs(回测指标[指标]) * 100
            else:
                差异[f'{指标}_相对'] = 0
        
        return 差异
    
    def _生成图表数据(self, 模拟盘历史净值: pd.DataFrame, 回测历史净值: pd.DataFrame) -> Dict[str, Any]:
        """
        生成对比图表数据。
        
        参数:
            模拟盘历史净值: 模拟盘历史净值DataFrame
            回测历史净值: 回测历史净值DataFrame
            
        返回:
            图表数据字典
        """
        # 准备净值对比数据
        净值对比 = {
            '日期': [],
            '模拟盘净值': [],
            '回测净值': []
        }
        
        # 合并日期
        所有日期 = set()
        
        if not 模拟盘历史净值.empty:
            所有日期.update(模拟盘历史净值['日期'])
        
        if not 回测历史净值.empty:
            所有日期.update(回测历史净值['日期'])
        
        所有日期 = sorted(所有日期)
        
        # 填充数据
        for 日期 in 所有日期:
            净值对比['日期'].append(日期)
            
            # 查找模拟盘净值
            if not 模拟盘历史净值.empty:
                模拟盘净值 = 模拟盘历史净值[模拟盘历史净值['日期'] == 日期]['净值'].values
                if len(模拟盘净值) > 0:
                    净值对比['模拟盘净值'].append(float(模拟盘净值[0]))
                else:
                    # 使用前一个有效值
                    if 净值对比['模拟盘净值']:
                        净值对比['模拟盘净值'].append(净值对比['模拟盘净值'][-1])
                    else:
                        净值对比['模拟盘净值'].append(1.0)
            else:
                净值对比['模拟盘净值'].append(1.0)
            
            # 查找回测净值
            if not 回测历史净值.empty:
                回测净值 = 回测历史净值[回测历史净值['日期'] == 日期]['净值'].values
                if len(回测净值) > 0:
                    净值对比['回测净值'].append(float(回测净值[0]))
                else:
                    # 使用前一个有效值
                    if 净值对比['回测净值']:
                        净值对比['回测净值'].append(净值对比['回测净值'][-1])
                    else:
                        净值对比['回测净值'].append(1.0)
            else:
                净值对比['回测净值'].append(1.0)
        
        # 计算净值差异
        净值对比['净值差异'] = [m - b for m, b in zip(净值对比['模拟盘净值'], 净值对比['回测净值'])]
        
        return {
            '净值对比': 净值对比
        }
